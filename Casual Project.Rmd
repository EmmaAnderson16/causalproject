---
title: "Causal Project"
author: "Emma Anderson"
date: "2024-04-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(shiny)
library(lubridate)
library(knitr)
library(ggplot2)
#library(plyr) # for count function
library(kableExtra)
library(tidyr)
library(dplyr)
library(tidyverse)
library(haven)
library(tableone)
#setwd("~/Documents/Github/causalproject")
```


```{r reading in and cleaning}
#exposure   
benzene <- read_xpt("P_UVOC2.XPT")
#limit of detection 9.81 
colnames(benzene)
benzene<-benzene[,-c(2,4:6)]
#outcome
repro <- read_xpt("P_RHQ.XPT")
repro$diabetes_binary <- ifelse(repro$RHQ162 == 2, 0, 1)
repro <- repro[,-c(2:17, 19:32)] 
#covariates
smoking <- read_xpt("P_SMQ.XPT")
smoking$smoke_binary <- ifelse(smoking$SMQ020 == 2, 0, 1)
smoking <- smoking[,-c(2:16)]
demographic <- read_xpt("P_DEMO.XPT")
colnames(demographic)
demographic <- demographic %>% filter(RIAGENDR==2)
demographic <- demographic[,-c(2:4,6:7,9:11,13:28)]
care <- read_xpt("P_HUQ.XPT")
care$care_binary <- ifelse(care$HUQ030 == 2, 1, 0)
care <- care[,-c(2:7)]
```

```{r}
#merge 
merged_data <- merge(benzene, repro, by = "SEQN")
merged_data <- merge(merged_data, smoking, by = "SEQN")
merged_data <- merge(merged_data, demographic, by = "SEQN")
merged_data <- merge(merged_data, care, by = "SEQN")

colnames(merged_data)

merged_data <- merged_data %>%
  rename(benzene = URXMUCA,
         diabetes = diabetes_binary, 
         baby_weight = RHQ172, 
         smoking = smoke_binary, 
         age = RIDAGEYR, 
         race = RIDRETH3, 
         education = DMDEDUC2, 
         income = INDFMPIR,
         access_care = care_binary
         )

merged_data <- merged_data[!is.na(merged_data$benzene) & !is.na(merged_data$diabetes), ]

#make benzene binary with median 48.15
summary(merged_data$benzene)

merged_data <- merged_data %>% 
  mutate(
    benzene_binary = ifelse(benzene <= 48.15, "Low", "High")
  )

table(merged_data$diabetes, merged_data$benzene_binary)


```

```{r}
merged_data <- merged_data %>% 
    mutate(race_category = case_when(
        race %in% c(1,2) ~ "Hispanic",
        race == 3 ~ "Non-Hispanic White",
        race == 4 ~ "Non-Hispanic Black",
        race == 6 ~ "Non-Hispanic Asian",
        race == 7 ~ "Other"
    ))

merged_data <- merged_data %>% 
    mutate(education_category = case_when(
        education %in% c(1,2) ~ "Less than high school",
        education == 3 ~ "High school diploma",
        education == 4 ~ "Some college",
        education == 5 ~ "College graduate or above"
    ))
```

```{r}
final_data <- merged_data[,c(1:6,9:13)]

final_data2 <- final_data[complete.cases(final_data), ]

```

```{r table1}
table.1.vars <- c("benzene_binary", "diabetes", "smoking", "age", "race_category", "education_category", "income", "access_care")
    
table.1.fvars <- c("race_category", "education_category", "diabetes", "smoking", "access_care")
    
table.1 <- CreateTableOne(vars = table.1.vars, 
                          strata = "benzene_binary",
                          factorVars = table.1.fvars,
                          data = final_data, includeNA=FALSE,
                          test=FALSE, addOverall=TRUE)
print(table.1)
```
G-comp
```{r}
final_data2 <- final_data2 %>% 
  mutate(
    benzene_numerical = ifelse(benzene_binary == "Low", 0, 1)
  )


reg.model <- glm(diabetes ~ benzene_numerical + smoking + age + income + access_care + race_category + education_category, family='binomial', data=final_data2)
summary(reg.model)
```

```{r}
exposed <- unexposed <- final_data2

exposed$benzene_numerical <- 1
unexposed$benzene_numerical <- 0

predictY.exposed<- predict(reg.model, newdata = exposed, type='response')
predictY.unexposed<- predict(reg.model, newdata = unexposed, type='response')

mean(predictY.exposed - predictY.unexposed)
```

Unadjusted estimator
```{r}
unadjusted <- mean(final_data2$benzene_numerical == 1) - mean(final_data2$benzene_numerical == 0)

unadjusted

```


```{r, IPW}
##### Inverse probability weighting
final_data <- final_data %>% 
  mutate(
    benzene_numerical = ifelse(benzene_binary == "Low", 0, 1)
  )
model.reg <- glm(benzene_numerical ~ smoking + age + income + access_care + race_category, family=binomial, 
               data=final_data) 
summary(model.reg)
#Estimate predicted probabilities of observed:
prob.1W <- predict(model.reg, type="response") # Predicted probability of observed
prob.0W <- 1-prob.1W # Predicted probability of not having diabetes 

summary(prob.1W)
summary(prob.0W)

#weights
wt1 <- as.numeric(final_data$benzene_numerical==1)/prob.1W
wt0 <- as.numeric(final_data$benzene_numerical==0)/prob.0W
summary(wt1)
summary(wt0)
#point estimates 
IPW<- mean(wt1*final_data$diabetes) - mean( wt0*final_data$diabetes)
IPW
mean( (wt1-wt0)*final_data$diabetes)
#Stabilized IPW estimator - Modified Horvitz-Thompson estimator
mean(wt1*final_data$diabetes)/mean( wt1) - mean( wt0*final_data$diabetes)/mean( wt0)
```

TMLE + bootstrapping (IGNORE)


Creating run.tmle function:
```{r}
set.seed(1)

library("SuperLearner")
# specify the library
SL.library<- c("SL.glm", "SL.step", "SL.glm.interaction")
#--------------------------------------------------
# 3: Create a run.tmle function to handcode simple substitution estimator,
# IPW, and TMLE - all using Super Learner
#--------------------------------------------------

run.tmle <- function(dt, SL.library){

 #------------------------------------------
 # Simple substitution estimator
 #------------------------------------------

 # dataframe X with the adjustment covariates and exposure
 X<- subset(dt, select=-diabetes)

 # set the exposure=1 in X1 and the exposure=0 in X0
 X1 <- X0 <-X
 X1$benzene_numerical <- 1 # exposed ('good guy')
 X0$benzene_numerical <- 0 # unexposed (not a 'good guy')

 # Estimate E_0(Y|A,W) with Super Learner
 SL.outcome <- SuperLearner(Y=dt$diabetes, X=X, SL.library=SL.library,
 family="binomial")

 # get the expected outcome, given the observed exposure and covariates
 expY.givenAW <- predict(SL.outcome, newdata=dt)$pred
 # expected outcome, given A=1 and covariates
 expY.given1W <- predict(SL.outcome, newdata=X1)$pred
 # expected outcome, given A=0 and covariates
 expY.given0W <- predict(SL.outcome, newdata=X0)$pred

 # simple substitution estimator is
 PsiHat.SS <- mean(expY.given1W - expY.given0W)

 #------------------------------------------
 # Inverse probability weighting
 #------------------------------------------

 # Super Learner for the exposure mechanism P_0(A=1|W)
 SL.exposure<- SuperLearner(Y=dt$benzene_numerical,
 X=subset(dt, select= -c(benzene_numerical,diabetes)),
 SL.library=SL.library, family="binomial")

 # generate the predicted prob of being exposed, given covariates
 probA1.givenW <- SL.exposure$SL.predict
 # generate the predicted prob of not being exposed, given covariates
  probA0.givenW <- 1- probA1.givenW

 # clever covariate
 H.AW <- as.numeric(dt$benzene_numerical==1)/probA1.givenW - as.numeric(dt$benzene_numerical==0)/probA0.givenW

 # also want to evaluate the clever covariate at A=1 and A=0 for all participants
 H.1W <- 1/probA1.givenW
 H.0W <- -1/probA0.givenW

 # IPW estimate
 PsiHat.IPW <- mean(H.AW*dt$diabetes)

 #------------------------------------------
 # Targeting & TMLE
 #------------------------------------------

 # Update the initial estimator of E_0(Y|A,W)
 # run logistic regression of Y on H.AW using the logit of the estimates as offset
 logitUpdate<- glm( dt$diabetes ~ -1 +offset(qlogis(expY.givenAW)) +
 H.AW, family='binomial')
 epsilon <- logitUpdate$coef

 # obtain the targeted estimates
 expY.givenAW.star<- plogis( qlogis(expY.givenAW)+ epsilon*H.AW )
 expY.given1W.star<- plogis( qlogis(expY.given1W)+ epsilon*H.1W )
 expY.given0W.star<- plogis( qlogis(expY.given0W)+ epsilon*H.0W )

 # TMLE point estimate
 PsiHat.TMLE<- mean(expY.given1W.star - expY.given0W.star)

 #------------------------------------------
 # Return a list with the point estimates, targeted estimates of E_0(Y|A,W),
 # and the vector of clever covariates
 #------------------------------------------

 # data.frame to hold point estimates
 estimates <- data.frame(cbind(PsiHat.SS=PsiHat.SS, PsiHat.IPW, PsiHat.TMLE))
 # data.frame to hold targeted outcome predictions
 predictions <- data.frame(cbind(expY.givenAW.star, expY.given1W.star,
 expY.given0W.star))
 # label the columns of predictions
 colnames(predictions)<- c('givenAW', 'given1W', 'given0W')
 # return a list
 return( list(estimates=estimates, predictions=predictions, H.AW=H.AW) )
 }
```

Assessing the point estimates from the function

```{r}
#final <- subset(final_data2, select=c("diabetes", "smoking", "age", "income", "access_care", "race_category", "education_category", "benzene_numerical"))

final <- subset(final_data2, select=-c(SEQN, benzene, baby_weight, benzene_binary))

out <- run.tmle(dt=final, SL.library=SL.library)
round(out$estimates*100, 5)
```


Bootstrapping to get 95% CIs:


```{r}
n <- nrow(final)
#################
# NP-Boot for B=500 bootstrapped samples
###################
# number of bootstrap samples
B <- 50
# data frame for estimates based on the bootstrap sample
est.boot<- data.frame(matrix(NA, nrow=B, ncol=3))
set.seed(1)
# for loop from b=1 to total number of bootstrap samples
for(b in 1:B){

 # sample the indices 1 to n with replacement
 index.boot<- sample(1:n, replace=T)
 dt.boot<- final[index.boot,]

 # calling the above function
 est.boot[b,] <- run.tmle(dt=dt.boot, SL.library=SL.library)$estimates

 # keep track of the iterations completed
 print(b)
}
colnames(est.boot)<-c("SS", "IPW", "TMLE")
save(est.boot, file='RLab6_boot.Rdata')
#---------------------------------
# Explore the bootstrapped point estimates
#---------------------------------
summary(est.boot)
var(est.boot[,'SS'])
var(est.boot[,'IPW'])
var(est.boot[,'TMLE'])


```

histograms:
```{r}

hist(est.boot[,'SS'], main="Histogram of point estimates from the Simple Substitution estimator over B bootstrapped samples", xlim=c(-.15, .15))
hist(est.boot[,'IPW'], main="Histogram of point estimates from IPW estimator over B bootstrapped samples", xlim=c(-.15, .15))
hist(est.boot[,'TMLE'], main="Histogram of point estimates from TMLE over B bootstrapped samples", xlim=c(-.15, .15))
```



```{r}
# 95% Confidence intervals assuming a normal dist & via quantiles
#---------------------------------
create.CI <- function(pt, boot, alpha=0.05){
 Zquant <- qnorm(alpha/2, lower.tail=F)
 CI.normal <- c(pt - Zquant*sd(boot), pt + Zquant*sd(boot) )
 CI.quant <- quantile(boot, prob=c(0.025,0.975) )

 yay<- data.frame(t ( c(pt, CI.normal, CI.quant))*100)
 colnames(yay)<- c('pt', paste0(c('CI.lo', 'CI.hi'), '.normal'),
 paste0(c('CI.lo', 'CI.hi'), '.quant') )
 round(yay, 1)
 }
# IMPORTANT - POINT OF CONFUSION FOR PAST STUDENTS
# The point estimate 'pt' is from the original dataset
set.seed(1)
out <- run.tmle(dt=final, SL.library=SL.library)
# Simple Subs
create.CI(pt=out$estimates$PsiHat.SS, boot=est.boot[,"SS"])
create.CI(pt=out$estimates$PsiHat.IPW, boot=est.boot[,"IPW"])
create.CI(pt=out$estimates$PsiHat.IPW, boot=est.boot[,"TMLE"])
```


```{r}
set.seed(1)


X<- subset(final, select=-diabetes)

 # set the exposure=1 in X1 and the exposure=0 in X0
 X1 <- X0 <-X
 X1$benzene_numerical <- 1 # exposed ('good guy')
 X0$benzene_numerical <- 0 # unexposed (not a 'good guy')

 # Estimate E_0(Y|A,W) with Super Learner
 SL.outcome <- SuperLearner(Y=final$diabetes, X=X, SL.library=SL.library,
 family="binomial")

 # get the expected outcome, given the observed exposure and covariates
 expY.givenAW <- predict(SL.outcome, newdata=final)$pred
 # expected outcome, given A=1 and covariates
 expY.given1W <- predict(SL.outcome, newdata=X1)$pred
 # expected outcome, given A=0 and covariates
 expY.given0W <- predict(SL.outcome, newdata=X0)$pred

 # simple substitution estimator is
 PsiHat.SS <- mean(expY.given1W - expY.given0W)
 
 PsiHat.SS
```
```{r}
set.seed(1)

# Super Learner for the exposure mechanism P_0(A=1|W)
 SL.exposure<- SuperLearner(Y=final$benzene_numerical,
 X=subset(final, select= -c(benzene_numerical,diabetes)),
 SL.library=SL.library, family="binomial")

 # generate the predicted prob of being exposed, given covariates
 probA1.givenW <- SL.exposure$SL.predict
 # generate the predicted prob of not being exposed, given covariates
  probA0.givenW <- 1- probA1.givenW

 # clever covariate
 H.AW <- as.numeric(final$benzene_numerical==1)/probA1.givenW - as.numeric(final$benzene_numerical==0)/probA0.givenW

 # also want to evaluate the clever covariate at A=1 and A=0 for all participants
 H.1W <- 1/probA1.givenW
 H.0W <- -1/probA0.givenW

 # IPW estimate
 PsiHat.IPW <- mean(H.AW*final$diabetes)
 PsiHat.IPW

```

```{r}
set.seed(1)

logitUpdate<- glm( final$diabetes ~ -1 +offset(qlogis(expY.givenAW)) +
 H.AW, family='binomial')
 epsilon <- logitUpdate$coef

 # obtain the targeted estimates
 expY.givenAW.star<- plogis( qlogis(expY.givenAW)+ epsilon*H.AW )
 expY.given1W.star<- plogis( qlogis(expY.given1W)+ epsilon*H.1W )
 expY.given0W.star<- plogis( qlogis(expY.given0W)+ epsilon*H.0W )

 # TMLE point estimate
 PsiHat.TMLE<- mean(expY.given1W.star - expY.given0W.star)
PsiHat.TMLE
 
```


```{r}
#------------------------------------------
 # Return a list with the point estimates, targeted estimates of E_0(Y|A,W),
 # and the vector of clever covariates
 #------------------------------------------

 # data.frame to hold point estimates
 estimates <- data.frame(cbind(PsiHat.SS=PsiHat.SS, PsiHat.IPW, PsiHat.TMLE))
 # data.frame to hold targeted outcome predictions
 predictions <- data.frame(cbind(expY.givenAW.star, expY.given1W.star,
 expY.given0W.star))
 # label the columns of predictions
 colnames(predictions)<- c('givenAW', 'given1W', 'given0W')
 # return a list
 estimates
 predictions
```

